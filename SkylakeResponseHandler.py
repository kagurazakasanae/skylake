#-*- coding: utf-8 -*-

import os,sys,time
from urllib import unquote
from getpass import getuser
from subprocess import Popen, PIPE, STDOUT
from SkylakeConfig import *

class SkylakeResponseHandler(object):
    def __init__(self, env):
        self.config = get_server_config()
        if type(self.config) != dict:
            raise Exception("Config load error")
        
        self.env = env
        del self.config['MAX_LENGTH']
        del self.config['TIMED_OUT']
        if 'GZIP' in self.config.keys():
            try:
                self.gzip = self.config['GZIP']
                self.gzip_min = self.config['GZIP_MIN']
                self.gzip_type = self.config['GZIP_TYPE'].split(',')
                del self.config['GZIP']
                del self.config['GZIP_MIN']
                del self.config['GZIP_TYPE']
            except:
                raise Exception("GZIP config error")
        else:
            self.gzip = False
            
        try:
            del self.config['ENABLE_LOG']
            del self.config['LOG_PATH']
        except:
            pass
        

    def response_handler(self):
        handleflag = False
        for i in self.config.keys():
            if 'MODE' not in self.config[i].keys() or 'HOME_PATH' not in self.config[i].keys():
                return self.set_error(500, 'Server Config load failed: HOME_PATH or/and MODE config is/are missing')
            if 'BIND_HOST' in self.config[i].keys() and self.config[i]['BIND_HOST'] == self.env['REQUEST_HOST']:
                handleflag = True
                if self.config[i]['MODE'] == 'BASIC':
                    self.env['REQUEST_URI'] = self.env['REQUEST_URI'].split('?')[0]
                    return self.basic_handler(self.config[i])
                elif self.config[i]['MODE'] == 'CGI':
                    return self.cgi_handler(self.config[i])
        
        if handleflag == False:
            return self.set_error(404, 'Host not found')

    def basic_handler(self, config):
        if 'DIR_LIST' not in config.keys():
            dir_list = False
        else:
            dir_list = config['DIR_LIST']
            
        uri = self.env['REQUEST_URI']
        document_path = os.path.abspath(config['HOME_PATH'] + uri)
        if not document_path.startswith(os.path.abspath(config['HOME_PATH'])):
            return self.set_error(403, 'Request Resource is not under HOME_PATH')
        if not os.path.exists(document_path):
            return self.set_error(404, 'File Not Found')
        if not os.path.isfile(document_path):
            if 'DEFAULT_PAGE' in config.keys():
                default_pages = config['DEFAULT_PAGE'].split(',')
                for i in default_pages:
                    if os.path.isfile(document_path+'/'+i):
                        return self.static_file_handler(document_path+'/'+i)

            if dir_list == False:
                return self.set_error(403, 'Directory list request denied')
            else:
                dirlist = []
                filelist = []
                page = '<html><head><title>Index of '+uri+'</title></head><body bgcolor="white"><h1>Index of '+uri+'</h1><hr><pre>'
                if uri != '/':
                    page += '<a href="../">../</a>                                               -                   -\n'
                for i in os.listdir(document_path):
                    if not os.path.isfile(document_path+'/'+i):
                        dirlist.append(i)
                    else:
                        filelist.append(i)
                list = dirlist+filelist
                for i in list:
                    if not os.path.isfile(document_path+'/'+i):
                        page += '<a href="'+i+'/">'+i+'</a>                                               '+time.strftime('%a, %d %b %Y %H:%M:%S',time.localtime(os.stat(document_path+'/'+i).st_mtime))+'                   -\n'
                    else:
                        page += '<a href="'+i+'">'+i+'</a>                                               '+time.strftime('%a, %d %b %Y %H:%M:%S',time.localtime(os.stat(document_path+'/'+i).st_mtime))+'                   '+str(int(round(os.path.getsize(document_path+'/'+i)/1024)))+'\n'

                page += '</pre><hr><h3>Generated by Skylake/0.1</h3></body></html>'
                return str(200), [('Content-Type', 'text/html;charset=utf-8')], page, False
        else:
            if 'DENIED_SUFFIX' in config.keys():
                for j in config['DENIED_SUFFIX']:
                    if document_path.lower().endswith(j):
                        return self.set_error(403, 'Request file suffix denied')

            return self.static_file_handler(document_path)
       
    def static_file_handler(self, document_path):
            headers = self.env['REQUEST_HEADERS']
            mime = get_mime_type()
            thismime = 'application/octet-stream'
            for i in mime.keys():
                if document_path.lower().endswith(i):
                    thismime = mime[i]
                    break

            if 'Range' not in headers.keys():
                if 'If-Modified-Since' in headers.keys():
                    if time.strftime('%a, %d %b %Y %H:%M:%S GMT',time.localtime(os.stat(document_path).st_mtime)) == headers['If-Modified-Since']:
                        return str(304), [('Last-Modified', headers['If-Modified-Since'])], '', True
                file = open(document_path,'rb').read()
                zipped = False
                if len(self.env['HTTP_ACCEPT_ENCODING']) > 0:
                    accept = self.env['HTTP_ACCEPT_ENCODING'].split(',')
                    for i in accept:
                        if i.replace(' ','') == 'gzip':
                            if int(round(os.path.getsize(document_path)/1024)) >= self.gzip_min and thismime in self.gzip_type:
                                import gzip
                                from cStringIO import StringIO
                                buf = StringIO()
                                f = gzip.GzipFile(mode='wb', fileobj=buf)
                                try:  
                                    f.write(file)
                                finally:  
                                    f.close()
                                file = buf.getvalue()
                                zipped = True
                                break
                
                headers = [('Content-Type', thismime),('Last-Modified', time.strftime('%a, %d %b %Y %H:%M:%S GMT',time.localtime(os.stat(document_path).st_mtime)))]
                if zipped == True:
                    headers.append(('Content-Encoding', 'gzip'))
                return str(200), headers, file, False
            else:
                range = headers['Range'].replace('bytes=','')
                range = range.split('-')
                if len(range) > 2:
                    return self.set_error(500, 'Cannot understand the range in the request')
                try:
                    srange = int(range[0])
                    if len(range[1]) > 0:
                        erange = int(range[1])
                    else:
                        erange = os.path.getsize(document_path)-1
                except ValueError:
                    return self.set_error(400, 'Bad request')
                f = open(document_path,'rb')
                f.seek(srange)
                file = f.read((erange - srange) + 1)
                return str(206), [('Content-Type', thismime),('Content-Range', 'bytes '+str(srange)+'-'+str(erange)+'/'+str(os.path.getsize(document_path)))], file, False

    def cgi_handler(self, config):
        if 'DIR_LIST' not in config.keys():
            dir_list = False
        else:
            dir_list = config['DIR_LIST']
        if 'CGI_SUFFIX' not in config.keys():
            cgi_suffix = {'.exe': '','.cgi': ''}
        else:
            cgi_suffix = config['CGI_SUFFIX']
        def is_cgi(filename, cgi_suffix):
            for i in cgi_suffix.keys():
                if filename.endswith(i):
                    return True, cgi_suffix[i]
            return False, ''

        uri = self.env['REQUEST_URI']
        document_path = os.path.abspath(config['HOME_PATH'] + uri).split('?')[0]
        
        if not document_path.startswith(os.path.abspath(config['HOME_PATH'])):
            return self.set_error(403, 'Request Resource is not under HOME_PATH')
        if not os.path.exists(document_path):
            return self.set_error(404, 'File Not Found')
        if not os.path.isfile(document_path):
            if 'DEFAULT_PAGE' in config.keys():
                default_pages = config['DEFAULT_PAGE'].split(',')
                for i in default_pages:
                    if os.path.isfile(document_path+'/'+i):
                        iscgi, handler = is_cgi(i, config['CGI_SUFFIX'])
                        if not iscgi:
                            return self.static_file_handler(document_path+'/'+i)
                        else:
                            return self.cgi_file_handler(document_path+'/'+i, config, handler)
            if dir_list == False:
                return self.set_error(403, 'Directory list request denied')
            else:
                return self.basic_handler(config)
        else:
            iscgi, handler = is_cgi(document_path, config['CGI_SUFFIX'])
            if not iscgi:
                if 'DENIED_SUFFIX' in config.keys():
                    for j in config['DENIED_SUFFIX']:
                        if document_path.lower().endswith(j):
                            return self.set_error(403, 'Request file suffix denied')

                return self.static_file_handler(document_path)
            else:
                return self.cgi_file_handler(document_path, config, handler)

    def cgi_file_handler(self, document_path, config, handler):
        os.putenv('SERVER_NAME', self.env['SERVER_NAME'])
        os.putenv('USER', getuser())
        os.putenv('HOME', config['HOME_PATH'])
        os.putenv('SCRIPT_FILENAME', document_path)
        os.putenv('HOME', config['HOME_PATH'])
        os.putenv('PATH_INFO', '')
        os.putenv('PATH_TRANSLATED', config['HOME_PATH'])
        QUERY_STRING = ''
        if '?' in self.env['REQUEST_URI']:
            QUERY_STRING = self.env['REQUEST_URI'][self.env['REQUEST_URI'].find('?')+1:]
        os.putenv('QUERY_STRING', QUERY_STRING)
        os.putenv('REQUEST_METHOD', self.env['REQUEST_METHOD'])
        CONTENT_TYPE = ''
        CONTENT_LENGTH = ''
        if self.env['REQUEST_METHOD'] not in ('GET','DELETE'):
            for i in self.env['REQUEST_HEADERS'].keys():
                if i.lower() == 'content-type':
                    CONTENT_TYPE = self.env['REQUEST_HEADERS'][i]
                    break
            CONTENT_LENGTH = self.env['REQUEST_HEADERS']['Content-Length']
        
        os.putenv('CONTENT_TYPE', CONTENT_TYPE)
        os.putenv('CONTENT_LENGTH', CONTENT_LENGTH)
        sn = os.path.abspath(document_path).replace(os.path.abspath(config['HOME_PATH']),'')
        if not sn.startswith('/'):
            sn = '/'+sn
        os.putenv('SCRIPT_NAME', sn)
        os.putenv('REQUEST_URI', self.env['REQUEST_URI'])
        os.putenv('DOCUMENT_URI', sn)
        os.putenv('DOCUMENT_ROOT', config['HOME_PATH'])
        os.putenv('SERVER_PROTOCOL', 'HTTP/'+self.env['HTTP_VERSION'])
        os.putenv('REQUEST_SCHEME', 'http')
        os.putenv('GATEWAY_INTERFACE', 'CGI/1.1')
        os.putenv('SERVER_SOFTWARE', 'Skylake/0.1')
        os.putenv('REMOTE_ADDR', self.env['CLIENT_ADDR'])
        os.putenv('REMOTE_PORT', str(self.env['CLIENT_PORT']))
        os.putenv('SERVER_ADDR', self.env['SERVER_ADDR'])
        os.putenv('SERVER_PORT', self.env['SERVER_PORT'])
        os.putenv('SERVER_NAME', self.env['SERVER_NAME'])
        os.putenv('HTTP_HOST', self.env['REQUEST_HOST'])
        HTTP_CONNECTION = 'close'
        for i in self.env['REQUEST_HEADERS'].keys():
            if i.lower() == 'connection':
                HTTP_CONNECTION = self.env['REQUEST_HEADERS'][i]
            if i.lower() == 'referer':
                os.putenv('HTTP_REFERER', self.env['REQUEST_HEADERS'][i])
        os.putenv('HTTP_CONNECTION', HTTP_CONNECTION)
        os.putenv('HTTP_USER_AGENT', self.env['USER-AGENT'])
        os.putenv('HTTP_ACCEPT', self.env['HTTP_ACCEPT'])
        os.putenv('HTTP_ACCEPT_ENCODING', self.env['HTTP_ACCEPT_ENCODING'])
        os.putenv('HTTP_ACCEPT_LANGUAGE', self.env['HTTP_ACCEPT_LANGUAGE'])
        os.putenv('HTTP_COOKIE', self.env['HTTP_COOKIE'])
        os.putenv('PHP_SELF', document_path.replace(os.path.dirname(config['HOME_PATH']),''))
        os.putenv('REQUEST_TIME_FLOAT', str(time.time()))
        os.putenv('REQUEST_TIME', str(time.time()).split('.')[0])
        os.putenv('REDIRECT_STATUS', str(200))
        try:
            if len(handler) > 0:
                p = Popen([handler, document_path], stdout=PIPE, stdin=PIPE, stderr=STDOUT)
            else:
                p = Popen([document_path], stdout=PIPE, stdin=PIPE, stderr=STDOUT)
        except:
            return self.set_error(500, 'Failed to run CGI program in order to handle this request')
        output = p.communicate(input=self.env['REQUEST_BODY'])[0]
        body = output[output.find("\r\n\r\n")+4:]
        headers = output[:output.find("\r\n\r\n")].split("\r\n")
        response_header = []
        statuscode = '200'
        thismime = 'application/octet-stream'
        already_encoded = False
        for i in headers:
            t = []
            t.append(i[:i.find(':')])
            t.append(i[i.find(':')+1:])
            if t[1].startswith(' '):
                t[1] = t[1][1:]
            if t[0] == 'Status':
                statuscode = t[1].split(' ')[0]
                continue
            response_header.append((t[0], t[1]))
            if t[0].lower() == 'content-type':
                thismime = t[1]
            if t[0].lower() == 'content-encoding':
                already_encoded = True
        zipped = False
        if not already_encoded:
            if len(self.env['HTTP_ACCEPT_ENCODING']) > 0:
                accept = self.env['HTTP_ACCEPT_ENCODING'].split(',')
                for i in accept:
                    if i.replace(' ','') == 'gzip':
                        if int(round(len(body)/1024)) >= self.gzip_min and thismime in self.gzip_type:
                            import gzip
                            from cStringIO import StringIO
                            buf = StringIO()
                            f = gzip.GzipFile(mode='wb', fileobj=buf)
                            try:  
                                f.write(body)
                            finally:  
                                f.close()
                            body = buf.getvalue()
                            zipped = True
                            break
            if zipped == True:
                response_header.append(('Content-Encoding', 'gzip'))
        return statuscode, response_header, body, False

    def set_error(self, status, message):
        error_page = get_error_page()
        if str(status) in error_page.keys():
            if os.path.isfile(error_page[str(status)]):
                page = open(error_page[str(status)]).read()
        else:
            page = '<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>HTTP Error '+str(status)+'</title></head><body><div id="main"><i><h2>Something error:</h2></i><p><h3>HTTP Error '+str(status)+'</h3><h3><font color=red>'+message+'.</font></h3></p><p>Please check or <a href="javascript:location.reload()">try again</a> later. </p>hostname: '+self.env['SERVER_NAME']+'<hr><div id="pb">Generated by Skylake/0.1</a>.</div></div></body></html>'
        return str(status), [('Content-Type', 'text/html;charset=utf-8')], page, False
            
        
            